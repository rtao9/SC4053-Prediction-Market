{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-484c4ce7937294b6081fc0cc5c23fc0f6aa6f200",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PredictionMarket.sol": "project/contracts/PredictionMarket.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/PredictionMarket.sol": {
        "content": "pragma solidity ^0.8.28;\r\n\r\ncontract PredictionMarket {\r\n    \r\n    uint256 public marketCountl;\r\n\r\n    enum MarketStatus { Open, Closed, Resolved }\r\n    enum Outcome { Undecided, Yes, No }\r\n\r\n    struct Market {\r\n        address creator;\r\n        string description;\r\n        MarketStatus status;\r\n        Outcome outcome;\r\n        uint256 totalYesBets;\r\n        uint256 totalNoBets;\r\n        uint256 resolutionTime;\r\n        mapping(address => uint256) playerStakes;\r\n        mapping(address => bool) betsYes;\r\n    }\r\n\r\n    mapping(uint256 => Market) public markets;\r\n\r\n    event MarketCreated(uint256 marketId, address creator, string description);\r\n    event BetPlaced(uint256 marketId, address bettor, bool betsYes, uint256 amount);\r\n    event MarketResolved(uint256 marketId, Outcome outcome);\r\n    event PayoutClaimed(uint256 marketId, address bettor, uint256 amount, string description);\r\n\r\n    function createMarket(string memory _description, uint256 _resolutionTime) external {\r\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\r\n        require(_resolutionTime > block.timestamp, \"Resolution time must be in the future\");\r\n\r\n        marketCountl++;\r\n        Market storage newMarket = markets[marketCountl];\r\n        newMarket.creator = msg.sender;\r\n        newMarket.description = _description;\r\n        newMarket.status = MarketStatus.Open;\r\n\r\n        emit MarketCreated(marketCountl, msg.sender, _description);\r\n    }\r\n\r\n    function placeBet(uint256 _marketId, bool _prediction) external payable {\r\n        require(_marketId > 0 && _marketId <= marketCountl, \"Invalid market ID\");\r\n\r\n        Market storage market = markets[_marketId];\r\n        require(market.status == MarketStatus.Open, \"Market is not open for betting\");\r\n        require(block.timestamp < market.resolutionTime, \"Betting period has ended\");\r\n        require(msg.value > 0, \"Bet amount must be greater than zero\");\r\n        require(_prediction == true || _prediction == false, \"Invalid prediction\");\r\n\r\n        if (_prediction) {\r\n            market.totalYesBets += msg.value;\r\n            market.betsYes[msg.sender] = true;\r\n        } else {\r\n            market.totalNoBets += msg.value;\r\n            market.betsYes[msg.sender] = false;\r\n        }\r\n        market.playerStakes[msg.sender] += msg.value;\r\n\r\n        emit BetPlaced(_marketId, msg.sender, _prediction, msg.value);\r\n    }\r\n\r\n    function resolveMarket(uint256 _marketId, bool _outcome) external {\r\n        require(_marketId > 0 && _marketId <= marketCountl, \"Invalid market ID\");\r\n\r\n        Market storage market = markets[_marketId];\r\n        require(market.status == MarketStatus.Open, \"Market is not open\");\r\n        require(block.timestamp >= market.resolutionTime, \"Resolution time has not been reached\");\r\n        require(msg.sender == market.creator, \"Only the market creator can resolve the market\");\r\n        require(_outcome == true || _outcome == false, \"Invalid outcome\");\r\n        require(market.outcome == Outcome.Undecided, \"Market has already been resolved\");\r\n\r\n        market.status = MarketStatus.Resolved;\r\n        market.outcome = _outcome ? Outcome.Yes : Outcome.No;\r\n\r\n        emit MarketResolved(_marketId, market.outcome);\r\n    }\r\n\r\n    function calculatePayout(uint256 _marketId, address _bettor) external view returns (uint256) {\r\n        require(_marketId > 0 && _marketId <= marketCountl, \"Invalid market ID\");\r\n\r\n        Market storage market = markets[_marketId];\r\n        require(market.status == MarketStatus.Resolved, \"Market is not resolved\");\r\n\r\n        uint256 bettorStake = market.playerStakes[_bettor];\r\n        if (bettorStake == 0) {\r\n            return 0;\r\n        }\r\n\r\n        bool bettorPrediction = market.betsYes[_bettor];\r\n        if ((market.outcome == Outcome.Yes && bettorPrediction) || (market.outcome == Outcome.No && !bettorPrediction)) {\r\n            uint256 totalWinningBets = market.outcome == Outcome.Yes ? market.totalYesBets : market.totalNoBets;\r\n            uint256 totalLosingBets = market.outcome == Outcome.Yes ? market.totalNoBets : market.totalYesBets;\r\n\r\n            return bettorStake + (bettorStake * totalLosingBets) / totalWinningBets;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function claimPayout(uint256 _marketId) external {\r\n        require(_marketId > 0 && _marketId <= marketCountl, \"Invalid market ID\");\r\n\r\n        uint256 payout = this.calculatePayout(_marketId, msg.sender);\r\n        require(payout > 0, \"No payout available\");\r\n\r\n        Market storage market = markets[_marketId];\r\n        market.playerStakes[msg.sender] = 0;\r\n\r\n        payable(msg.sender).transfer(payout);\r\n\r\n        emit PayoutClaimed(_marketId, msg.sender, payout, \"Payout Claimed\");\r\n    }\r\n\r\n    function getMarketCount() external view returns(uint256 _marketCount){\r\n        return marketCountl;\r\n    }\r\n\r\n    function getMarketDetails(uint256 _marketId) external view returns (\r\n        address creator,\r\n        string memory description,\r\n        MarketStatus status,\r\n        Outcome outcome,\r\n        uint256 totalYesBets,\r\n        uint256 totalNoBets,\r\n        uint256 resolutionTime\r\n    ){\r\n        require(_marketId > 0 && _marketId <= marketCountl, \"Invalid market ID\");\r\n        Market storage market = markets[_marketId];\r\n        return (\r\n            market.creator,\r\n            market.description,\r\n            market.status,\r\n            market.outcome,\r\n            market.totalYesBets,\r\n            market.totalNoBets,\r\n            market.resolutionTime\r\n        );\r\n    }\r\n\r\n    function getBettorStake(uint256 _marketId, address _bettor) external view returns (uint256 stake, bool votedYes){\r\n        require(_marketId > 0 && _marketId <= marketCountl, \"Invalid market ID\");\r\n\r\n        Market storage market = markets[_marketId];\r\n        return (market.playerStakes[_bettor], market.betsYes[_bettor]);\r\n    }\r\n\r\n    function getMarketOutcome(uint256 _marketId) external view returns (Outcome outcome){\r\n        require(_marketId > 0 && _marketId <= marketCountl, \"Invalid market ID\");\r\n\r\n        Market storage market = markets[_marketId];\r\n        return (market.outcome);\r\n    }\r\n\r\n}\r\n"
      }
    }
  }
}